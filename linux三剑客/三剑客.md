# grep 、sed和awk

## 正则表达式元字符

元字符也是一种字符,但他表达的含义不同于字符本身的字面含义。例如,^和$就是元字符。

**使用正则表达式时要特别留意当时环境语系是什么，否则可能会发现与别人不相同的选取结果。**

为了要避免编码所造成的英文与数字呃选取问题，有些特殊符号需要了解，这些符号主要有下面这些意义。

|  特殊符号  |                   代表意义                    |
| :--------: | :-------------------------------------------: |
| [:alnum:]  |   代表英文大小写字符及数字，即0~9，A~Z,a~z    |
| [:alpha:]  |     代表任何英文大小写字符，亦即A-Z，a-z      |
| [:lower:]  |               小写字母,亦即a-z                |
| [:upper:]  |               大写字母,亦即A-Z                |
| [:blank:]  |            代表空格键与Tab按键两者            |
| [:space:]  | 任何会产生空白的字符，包括空格键、Tab键、CR等 |
| [:cntrl:]  |  代表键盘上的控制按键，包括CR、LF、Tab、Del   |
| [:digit:]  |                   十进制数                    |
| [:xdigit:] |                  十六进制数                   |
| [:graph:]  |   除了空格符(空格键与Tab键)外的其他所有按键   |
| [:print:]  |         代表任何可以被打印出来的字符          |
| [:punct:]  |                 代表标点符号                  |



**表  正则表达式元字符**

|   元字符   |                    功能                     |      示例       |                        示例的匹配对象                        |
| :--------: | :-----------------------------------------: | :-------------: | :----------------------------------------------------------: |
|     ^      |                 行首定位符                  |     /^love/     |                   匹配所有以 love 开头的行                   |
|     $      |                 行尾定位符                  |     /love$/     |                   匹配所有以 love 结尾的行                   |
|     .      |           匹配除换行外的单个字符            |     /l..e/      |         匹配包含字符 l、后跟两个任意字符、再跟字母 e         |
|     *      | 匹配前面的字符任意次，包括0次(**贪婪模式**) |     /*love/     |              匹配在零个或多个空格紧跟着love的行              |
|     []     |          匹配指定字符组内任一字符           |    /[Ll]ove/    |                  匹配包含 love 和 Love 的行                  |
|    [^]     |        匹配不在指定字符组内任一字符         | /[^A-KM-Z\]ove/ | 匹配包含ove，但ove之前的那个字符不在 A 至 K 或 M 至 Z 间的行 |
|     &      |        保存查找串以便在替换串中引用         | s/love/\**&**/  | 符号&代表查找串。字符串 love将替换前后各加了两个\**的引用,即 love 变成\*\*love** |
|    \\<     |                 词首定位符                  |    /\\<love/    |                匹配包含以 love 开头的单词的行                |
|    \\>     |                 词尾定位符                  |    /love\\>/    |                匹配包含以 love 结尾的单词的行                |
|  x\\{m\\}  |                 连续 m 个 x                 |   /o\\{5\\}/    |                   匹配出现连续 5 个字母 o                    |
| x\\{m,\\}  |                 至少 m 个 x                 |   /o\\{5,\\}/   |                 匹配至少出现连续 5 个字母 o                  |
| x\\{m,n\\} |           至少m个x，但不超过n个x            |  /o\\{5,10\\}/  |                    匹配 5到10个连续字母 o                    |

**表 扩展正则表达式**

| 元字符 |                          意义与范例                          |
| :----: | :----------------------------------------------------------: |
|   +    | 意义：重复一个或一个以上的前一个RE字符。范例：查找god、good、goood等字符串。那个o+代表一个以上的o，如egrep -n 'go+d' regular_experess.txt |
|   ?    |                意义：零个或一个前一个RE字符。                |
|   \|   | 意义：用或的方式找出数个字符串。范例：查找gd或good这两个字符串，如egrep -n 'gd\|good' regular_express.txt |
|   ()   | 意义：找出群组字符串。范例：查找glad或good这两个字符串，如egrep -n 'g(la\|oo)d' regular_express.txt |
|  ()+   | 意义：多个重复群组的判别。范例：将【AxyzxyzxyzC】用echo打印，然后再使用如下方法查找一下。echo 'AxyzxyzxyzC' \| egrep 'A(xyz)+C' |

**注意：**

()是将一个或多个字符捆绑在一起，当作一个整体进行处理，即分组。分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\1,\2,\3,… 。\1表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符。**向后引用：**引用前面的分组括号中的模式所匹配字符，而非模式本身。

## 1.grep命令

grep是一个全局查找正则表达式并打印结果行的命令，是在一个或多个文件中查找某个字符模式。

**命令格式**

grep [ 选项] 模式 [文件...]

**表  grep选项**

| 选项 |                             功能                             |
| :--: | :----------------------------------------------------------: |
|  -E  | 如果加这个选项,那么后面的匹配模式就是扩展的正则表达式,也就是 grep -E= egrep |
|  -i  |                   比较字符时忽略大小写区别                   |
|  -w  | 把表达式作为词来查找,相当于正则中的"\\<...\\>"(...表示你自定义的规则) |
|  -x  |        被匹配到的内容,正好是整个行,相当于正则"^...$"         |
|  -v  |            取反,也就是输出我们定义模式相反的内容             |
|  -c  | count.统计,统计匹配结果的行数,主要不是匹配结果的次数,是行数。 |
|  -m  |           只匹配规定的行数,之后的内容就不在匹配了            |
|  -n  | 在输出的结果里显示行号,这里要清楚的是这里所谓的行号是该行内容在原文件中的行号,而不是在输出结果中行号 |
|  -o  | 只显示匹配内容,grep 默认是显示满足匹配条件的一行,加上这个参数就只显示匹配结果,比如我们要匹配一个 ip 地址,就只需要结果,而不需要该行的内容。 |
|  -R  | 递归匹配。如果要在一个目录中多个文件或目录匹配内容,则需要这个参数 |
|  -B  | 输出满足条件行的前几行,比如 grep -B 3 "aa" file 表示在 file 中输出有 aa 的行,同时还要输出 aa 的前 3 行 |
|  -A  |             这个与-B 类似,输出满足条件行的后几行             |
|  -C  |            这个相当于同时用-B -A,也就是前后都输出            |

案例1：

```shell
grep Tom /etc/passwd
```

grep 将在文件中查找/etc/passwd 中查找模式 Tom。如果查找成功，文件中相应行会显示在屏幕上，如果没有找到指定的模式，就不会有任何输出，如果指定的文件不是一个合法的文件，屏幕上就会显示报错信息。如果发现了要查找的模式，grep 就返回退出状态 0，表示成功，如果没找到，返回的退出状态为 1，而找不到指定文件时，退出状态将是 2。

案例2：

```shell
grep '[^0-9]' grep.txt
```

打印包含非数字字符的行。

## 2. sed命令

### 2.1 sed简介

sed 是一种新型的，非交互式的编辑器。它能执行与编辑器 vi 和 ex 相同的编辑任务。sed 编辑器没有提供交互式使用方式，使用者只能在命令行输入编辑命令、指定文件名，然后在屏幕上查看输出。sed 编辑器没有破坏性，它不会修改文件，除非使用 shell 重定向来保存输出结果。默认情况下，所有的输出行都被打印到屏幕上。

### 2.2 sed工作过程

sed 编辑器逐行处理文件（或输入），并将输出结果发送到屏幕。sed 的命令就是在 vi和 ed/ex 编辑器中见到的那些。sed 把当前正在处理的行保存在一个临时缓存区中，这个缓存区称为模式空间或临时缓冲。 sed 处理完模式空间中的行后（即在该行上执行 sed 命令后），就把该行发送到屏幕上（除非之前有命令删除这一行或取消打印操作）。sed 每处理完输入文件的最后一行后，sed 便结束运行。sed 把每一行都存在临时缓存区中，对这个副本进行编辑，所以不会修改或破坏源文件。如图 ：sed 处理过程。

![](/home/sunny/Nutstore Files/我的坚果云/TyporaFile/linux三剑客/sed工作过程.png)

### 2.3 sed命令格式

sed 命令行格式为： sed [选项] ‘command’ 输入文本

**sed定位**

Sed 命令在没有给定的位置时，默认会处理所有行；
Sed 支持以下几种地址类型：

1、first~step
这两个单词的意思：first 指起始匹配行，step 指步长，例如：sed -n 2~5p 含义：从第二
行开始匹配，隔 5 行匹配一次，即 2,7,12.......。
2、$
这个$符表示匹配最后一行。
3、/REGEXP/
这个是表示匹配正则那一行，通过//之间的正则来匹配。
4、\cREGEXPc
这个是表示匹配正则那一行，通过\c 和 c 之间的正则来匹配,c 可以是任一字符
5、addr1，add2

定址 addr1，add2 决定用于对哪些行进行编辑。地址的形式可以是数字、正则表达式或
二者的结合。如果没有指定地址，sed 将处理输入文件中的所有行。
如果定址是一个数字，则这个数字代表行号，如果是逗号分隔的两个行号，那么需要处
理的定址就是两行之间的范围（包括两行在内）。范围可以是数字，正则或二者组合。

6、addr1，+N
从 addr1 这行到往下 N 行匹配，总共匹配 N+1 行
7、addr1，~N
Will match addr1 and the lines following addr1 until the next line whose input line
number is a multiple of N.

### 2.4 sed常用选项

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -n   | 使用安静模式，在一般情况所有的 STDIN 都会输出到屏幕上，加入-n 后只打印被 sed 特殊处理的行 |
| -e   | 多重编辑，且命令顺序会影响结果                               |
| -f   | 指定一个 sed 脚本文件到命令行执行，                          |
| -r   | Sed 使用扩展正则                                             |
| -i   | 直接修改文档读取的内容，不在屏幕上输出                       |

### 2.5 sed操作命令

sed 操作命令告诉 sed 如何处理由地址指定的各输入行。如果没有指定地址，sed 就会处理输入的所有的行。

表 sed命令

| 命令  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| a  \  | 在当前行后添加一行或多行                                     |
| c   \ | 用新文本修改（替换）当前行中的文本                           |
| d     | 删除行                                                       |
| i  \  | 在当前行之前插入文本                                         |
| h     | 把模式空间里的内容复制到暂存缓存区                           |
| H     | 把模式空间里的内容追加到暂存缓存区                           |
| g     | 取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容 |
| G     | 取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面 |
| l     | 列出非打印字符                                               |
| p     | 打印行                                                       |
| n     | 读入下一输入行，并从下一条命令而不是第一条命令开始处理       |
| q     | 结束或退出 sed                                               |
| r     | 从文件中读取输入行                                           |
| ！    | 对所选行以外的所有行应用命令                                 |
| s     | 用一个字符串替换另一个                                       |

表 替换标志

| 标志 | 说明                                                |
| ---- | --------------------------------------------------- |
| g    | 在行内进行全局替换                                  |
| p    | 打印行                                              |
| w    | 将行写入文件                                        |
| x    | 交换暂存缓冲区与模式空间的内容                      |
| y    | 将字符转换为另一字符（不能对正则表达式使用 y 命令） |

## 3. awk

awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。awk 是三剑客的老大，利剑出鞘，必会不同凡响。

### 3.1 awk原理

通过一个简短的命令，我们来了解其工作原理。

```shell
awk '{print $0}' /etc/passwd
echo hhh|awk '{print "hello,world"}'
awk '{ print "hiya" }' /etc/passwd
```

你将会见到/etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。现在，解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。再次说明，awk 对输入文件中的每一行都执行这个脚本。

![](/home/sunny/Nutstore Files/我的坚果云/TyporaFile/linux三剑客/awk示意图.png)

### 3.2 BEGIN和END模块

通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。
awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行
这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。

### 3.3 运算符

![](/home/sunny/Nutstore Files/我的坚果云/TyporaFile/linux三剑客/运算符.png)

### 3.4 常用awk内置变量

| 变量名 | 属性                                  |
| ------ | ------------------------------------- |
| $0     | 当前记录                              |
| $1~$n  | 当前记录的第 n 个字段                 |
| FS     | 输入字段分隔符 默认是空格             |
| RS     | 输入记录分割符 默认为换行符           |
| NF     | 当前记录中的字段个数，就是有多少列    |
| NR     | 已经读出的记录数，就是行号，从 1 开始 |
| OFS    | 输出字段分隔符 默认也是空格           |
| ORS    | 输出的记录分隔符 默认为换行符         |

### 3.5 awk的if、循环和数组

#### 3.5.1 条件语句

awk提供了非常好的类似c语言的if语句。

#### 3.5.2 循环结构

awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。awk 还有"do...while"循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。

**for循环**

awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：

**break和continue**

此外，如同 C 语言一样，awk 提供了 break 和 continue 语句。使用这些语句可以更好地
控制 awk 的循环结构。





**具体使用详见linux三剑客常用命令**
